#version 460 core
layout(local_size_x = 64) in;

struct ChunkMetadata {
    int X, Y, Z;
    uint instanceCount;
    uint first;
    uint number;
    int pad1, pad2;
};

struct DrawCommand {
    uint count;
    uint instanceCount;
    uint first;
    uint baseInstance;
};

layout(std430, binding = 0) readonly restrict buffer Chunks { ChunkMetadata chunks[]; };
layout(std430, binding = 3) writeonly restrict buffer OutCmds { DrawCommand commands[]; };
layout(std430, binding = 4) restrict buffer Counter { uint drawCount; };

// Плоскости передаем с CPU (0:Left, 1:Right, 2:Bottom, 3:Top, 4:Near, 5:Far)
uniform vec4 frustumPlanes[6];
uniform vec3 camPos;
uniform uint totalChunks;

// Проверка AABB относительно плоскостей (Optimized P-Vertex approach)
bool isAABBVisible(vec3 minPos, vec3 maxPos) {
    // Проходим по всем 6 плоскостям
    // (Можно развернуть цикл вручную, но компилятор сделает это сам)
    for (int i = 0; i < 6; ++i) {
        vec4 plane = frustumPlanes[i];

        // Находим "Positive Vertex" - точку AABB, максимально удаленную в сторону нормали плоскости.
        // Это единственный угол, который нужно проверить.
        vec3 p;
        p.x = (plane.x > 0) ? maxPos.x : minPos.x;
        p.y = (plane.y > 0) ? maxPos.y : minPos.y;
        p.z = (plane.z > 0) ? maxPos.z : minPos.z;

        // Если самая "выпирающая" точка находится ЗА плоскостью (в отрицательной зоне),
        // то и весь AABB находится за плоскостью -> чанк невидим.
        if (dot(plane.xyz, p) + plane.w < 0.0) {
            return false;
        }
    }
    return true;
}

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= totalChunks) return;

    // Считываем метаданные
    // Сначала только instanceCount, чтобы лишний раз не грузить память, если 0
    uint cnt = chunks[idx].instanceCount;
    if (cnt == 0) return;

    ChunkMetadata chunk = chunks[idx];

    // Координаты AABB в мире
    vec3 worldMin = vec3(chunk.X, chunk.Y, chunk.Z) * 32.0;

    // Relative to camera (для точности float при больших координатах)
    // Плоскости должны быть рассчитаны с учетом ViewRotation (без трансляции камеры)
    // либо плоскости обычные (ViewProjection), а тут worldMin без вычитания camPos.
    // Если используете "Camera Relative" подход (как обсуждали):
    vec3 relMin = worldMin - camPos;
    vec3 relMax = relMin + 32.0;

    if (isAABBVisible(relMin, relMax)) {
        uint cmdIdx = atomicAdd(drawCount, 1);

        DrawCommand cmd;
        cmd.count = 4;
        cmd.instanceCount = cnt; // Важно: используем локальную переменную cnt
        cmd.first = 0;
        cmd.baseInstance = idx;

        commands[cmdIdx] = cmd;
    }
}